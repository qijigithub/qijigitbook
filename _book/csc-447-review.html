
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Csc 447 Review Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="the language included are scheme, c, java, scala, javascript">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="data-structure-review-in-java.html" />
    
    
    <link rel="prev" href="_book/untitled.md" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Book
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="_book/data-structure-review-in-java.md">
            
                <span>
            
                    
                    Data Structure Review In Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="_book/untitled.md">
            
                <span>
            
                    
                    Untitled
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter active" data-level="1.3" data-path="csc-447-review.html">
            
                <a href="csc-447-review.html">
            
                    
                    Csc 447 Review
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="data-structure-review-in-java.html">
            
                <a href="data-structure-review-in-java.html">
            
                    
                    Data Structure Review In Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="drafts.html">
            
                <a href="drafts.html">
            
                    
                    Drafts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="oop-design-pattern.html">
            
                <a href="oop-design-pattern.html">
            
                    
                    Oop Design Pattern
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="untitled.html">
            
                <a href="untitled.html">
            
                    
                    Untitled
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Csc 447 Review</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="csc-447-review">CSC 447 review</h1>
<h2 id="lecture-1">Lecture 1</h2>
<h3 id="class-notes">class notes</h3>
<h4 id="overview">overview</h4>
<ul>
<li>machines and programs<ul>
<li>machines=input simulation+output responce</li>
<li>program:perticular responce and store in memory<ul>
<li>computing=control and memory</li>
<li>fixed program before computuation begins,and store in the memory</li>
</ul>
</li>
<li>time<ul>
<li>before program: compile time</li>
<li>after program:run tiime</li>
</ul>
</li>
<li>finer grained<ul>
<li>compiler: compile,link, load</li>
<li>memory: allocation, initialization, deallocation</li>
<li>function: call, return</li>
</ul>
</li>
<li>memory<ul>
<li>copying and sharing</li>
<li>allcation and deallocation</li>
<li>categories<ul>
<li>globe</li>
<li>local</li>
<li>unmamanaged</li>
<li>ARC and garbage collection</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>interpretation and translation<ul>
<li>machine language to program language</li>
<li>transforamed into equivalent program: c# to visual machine language</li>
</ul>
</li>
<li>designing a language<ul>
<li>resource constraints</li>
<li>programming model</li>
<li>error</li>
<li>module</li>
</ul>
</li>
</ul>
<h4 id="cstatements-versus-expression-strict-versus-non-strict-and-undefined-behavior">c:statements versus expression, strict versus non strict and undefined behavior</h4>
<ul>
<li>statement and expression<ul>
<li>statements:executed for side-effects, eg: literal,operators,function call</li>
<li>expression:executed for their value(for side effect),eg:loop ifelse, return and expression statements(include assignment)</li>
<li>PS: side-effect eg: x++, x plus 1 and change x value<ul>
<li>side-effecting expression:x++</li>
</ul>
</li>
</ul>
</li>
<li>comma operator (e1,e2,e3)</li>
<li>sequencing:</li>
</ul>
<pre><code class="lang-text">1
int x=5;
x*=2;
print (x)

2
int x=5;
print(&quot;%d\n&quot;,(x*=2,x))
the semantics is not same,but result is same
</code></pre>
<ul>
<li>strict and non strict<ul>
<li>strict: if it evaluate all of its operands before it runst<ul>
<li>eg: operators:+,-,*,/ | comparson:&lt;,&lt;=,==, != | bitwise:|,&amp;&lt;,!,^|function call| etc</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcond</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> f)</span> </span>{ <span class="hljs-keyword">return</span> b ? t : f; }<span class="hljs-comment">//function</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) {
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> z = fcond (rand()%<span class="hljs-number">2</span>,  (x=<span class="hljs-number">1</span>,<span class="hljs-number">111</span>), (y=<span class="hljs-number">2</span>,<span class="hljs-number">222</span>));
    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;x=%d, y=%d, z=%d\n&quot;</span>, x, y, z);
  }
}

outout:
x=<span class="hljs-number">1</span>, y=<span class="hljs-number">2</span>, z=<span class="hljs-number">111</span>
x=<span class="hljs-number">1</span>, y=<span class="hljs-number">2</span>, z=<span class="hljs-number">222</span>
</code></pre>
<ul>
<li>non strict:evaluate part of its operands<ul>
<li>eg &amp;&amp;,||,e1?e2:e3 (ternary operator)| macro expansion </li>
</ul>
</li>
</ul>
<pre><code class="lang-c">define mcond(b, t, f) (b)?(t):(f) //macro expansion
int main () {
  for (int i=0; i&lt;10; i++) {
    int x = 0;
    int y = 0;
    int z = mcond (rand()%2,  (x=1,111), (y=2,222));
    printf (&quot;x=%d, y=%d, z=%d\n&quot;, x, y, z);
  }
}
output:
x=1, y=0, z=111
x=0, y=2, z=222
</code></pre>
<p>Because function is strict, before execute function mcond, x=1, and y=2, z=111or 222. Macro call is not strict, so that the function mcond execute first when meeting b go back find the parameter b, random/2!= 0 true, and meeting t, t=1,111 and ignore y=2, 222. macro calls are evaluated in the compiler, by textual substitution.</p>
<ul>
<li>conditional  statment and conditional expression<ul>
<li>conditional statement</li>
</ul>
</li>
</ul>
<pre><code class="lang-text">int fact(int n){
    if(n&lt;1){
        return 1;
    }
    else{
       return n*fact(n-1); 
    }
}
</code></pre>
<ul>
<li>conditional expression</li>
</ul>
<pre><code class="lang-text">int fact(int n){
    return (n&lt;1)?1:n*fact(n-1);
}
</code></pre>
<p>Because  conditional expression use expression and didn&apos;t use statement.</p>
<ul>
<li>undefined behavior<ul>
<li>under/overflow</li>
</ul>
</li>
</ul>
<pre><code class="lang-text">#include &lt;stdio.h&gt;

int isMinValue (int x) {
  return (x-1) &gt; x;
}
int main () {
  int i = -2000000000;  //c no boolean type  integer 0 or 1
  while (!isMinValue(i))
    i--;
  printf (&quot;Min value is %d\n&quot;, i);
}
 output1:
 $ gcc -O1 undefined.c &amp;&amp; ./a.out 
Min value is -2147483648
</code></pre>
<pre><code class="lang-text">$ gcc -O2 undefined.c &amp;&amp; ./a.out 
^C #infinite loop
</code></pre>
<p>O1 explanation: when execute isMinValue(x): i-1, and compare with x, if x-1 &gt;x  return 1, else return 0, -2000000000-1-1-1-1...,x-1 always less than x, return false. until i=-2,147,483,648, which minus 1 is underflow, the result is 2147483647. the function return value is true, and print -2,147,483,648 is min value.</p>
<p>O2 explanation: the result is infinit loop, because the underflow in c is undefined behavior, what the compiler do is x-1&gt;x, is always true,so it is infinit loop.</p>
<ul>
<li>order of operations</li>
</ul>
<pre><code class="lang-text">#include &lt;stdio.h&gt;
int count = 0;
int f () {
  count += 1;
  return count;
}
int main () {
  int z = f() + f();
  printf (&quot;%d\n&quot;, z);
  z = (z += 1) + (z = z*z);
  printf (&quot;%d\n&quot;, z);
}
 output&#xFF1A;
$ clang -Wall undefined3.c 
undefined3.c:11:21: warning: unsequenced modification and access to &apos;z&apos;
  z = (z += 1) + (z = z*z);
         ~~         ^
1 warning generated.
$ ./a.out 
3
20
</code></pre>
<p>it runs in clang, the compiler gives a warning because it is not run in the right order, the sequence of run first f() and second f() is random, depends on compile. Thus it is undefined behavior.</p>
<ul>
<li>dangling pointers</li>
</ul>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">foo</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  <span class="hljs-keyword">int</span> result = <span class="hljs-number">2</span> * n;
  <span class="hljs-keyword">return</span> &amp;result;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span>* p = foo (<span class="hljs-number">5</span>);
  <span class="hljs-keyword">int</span>* q = foo (<span class="hljs-number">7</span>);
  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;%x %d\n&quot;</span>, p, *p);
  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;%x %d\n&quot;</span>, q, *q);  
}
output: 
in clang: 
<span class="hljs-number">14</span> and big number
in gcc:
segment error
</code></pre>
<p>p and q in main function point into an activation record, which is stack, and when the function executing finished, the memory of that function will be deallocated.</p>
<h4 id="scheme">scheme</h4>
<ul>
<li>literal<ul>
<li>number:5</li>
<li>String:&quot;hello world&quot;</li>
<li>symbol:&apos;hello world&apos;</li>
</ul>
</li>
<li>arithmetic <ul>
<li>using prefix notation: (* (+ 1 2) 3)</li>
</ul>
</li>
<li>function<ul>
<li>define: (define (square n) (* n n))<ul>
<li>(define (f p1 p2 p3...) (e1 e2...))</li>
</ul>
</li>
<li>invoke: (square 5 2)</li>
</ul>
</li>
<li>boolean and condiaitonals<ul>
<li>#t or #f</li>
<li>if is not strict</li>
</ul>
</li>
<li>recursive function</li>
<li><p>con cells</p>
<ul>
<li>pair of numbers:(cons 1 2)| strings:(cons &quot;hello&quot; &quot;world&quot;)| a number and  a string: (cons 1 &quot;world&quot;)</li>
<li>car: head | cdr: tail</li>
<li><p>for linked list</p>
<ul>
<li>empty list: ()</li>
<li>singleton list: (cons 3 ())</li>
<li>regular list:(cons 1 (cons 2 (cons 3 ())))</li>
</ul>
</li>
<li><p>list</p>
<ul>
<li>list only has one structure type: the pair</li>
<li>a non-empty list is just a special type of pair</li>
<li>pairs are a kind of symbolic-expression</li>
</ul>
</li>
</ul>
</li>
<li><p>syntax sugar for lists</p>
<ul>
<li>quote: special form prevent evaluation: (quote (1 2 3))</li>
<li>&apos; :shorthand for quote &apos;(1 2 3)</li>
<li>list function evaluates args, put results in a list: (list 2 3 (+1 2))</li>
</ul>
</li>
<li><p>equals problem</p>
<ul>
<li>eq? compares two pointers are same, same to java ==</li>
<li>equal? compares two structure are same to java equals</li>
</ul>
</li>
<li>read-eval-print loop<ul>
<li>quote:delay evaluation</li>
<li>eval: evaluates an expression</li>
<li>read function reads the expression</li>
</ul>
</li>
</ul>
<h3 id="worksheet">worksheet</h3>
<h3 id="homework">homework</h3>
<h3 id="quiz">quiz</h3>
<h2 id="lecture2">Lecture2</h2>
<h3 id="class-notes">class notes</h3>
<ul>
<li><p>types&#xFF1A;used to describe when operations allowed</p>
<ul>
<li>&quot;+&quot; in java: string, numeric types</li>
<li>&quot;-&quot; in java: numeric types</li>
</ul>
</li>
<li><p>dynamic type checking and  static type checking</p>
</li>
<li><strong>dynamic type checking</strong>: tracks and stores type of data at runtime(before applying an operation).<ul>
<li>how do we know this is dynamic? answer: no type checking before execution.<ul>
<li>when writing an expression in function, invoke function there is no error message, but fails when call function.</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-scheme">(define (f) (- 5 &quot;hello&quot;))  no error at here
(f)
output:
Error in -: expected type number, got &apos;&quot;hello&quot;&apos;.
</code></pre>
<ul>
<li><ul>
<li>Language use:</li>
</ul>
</li>
<li><strong>static type checking</strong>:compiler analyzes code for type error<ul>
<li>how do we know this is static; answer: javac and get the error message.</li>
</ul>
</li>
</ul>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Typing01</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;
    String b = <span class="hljs-string">&quot;hello&quot;</span>;
    System.out.println (<span class="hljs-string">&quot;Result = &quot;</span> + (a - b));
  }
}

output:
$ javac Typing01.java
Typing01.java:<span class="hljs-number">5</span>: error: bad operand types <span class="hljs-keyword">for</span> binary operator <span class="hljs-string">&apos;-&apos;</span>
    System.out.println (<span class="hljs-string">&quot;Result = &quot;</span> + (a - b));
                                         ^
  first type:  <span class="hljs-keyword">int</span>
  second type: String
</code></pre>
<ul>
<li>Language : C, Java, Scala, Haskell, Rust, Coq, etc</li>
</ul>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">char</span> a[] = { <span class="hljs-number">0x85</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x88</span> };
  <span class="hljs-keyword">int</span> b = a[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">char</span> *p = &amp;a[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">int</span> *q = p;       <span class="hljs-comment">/* type checker complains */</span>
  <span class="hljs-keyword">int</span> c = *q;
  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;b = %08x, p = %p, q = %p, c = %08x\n&quot;</span>, b, p, q, c);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>if char convert to int, it is allowed, but if the pointer of char convert to the pointer of int, it is not allowed.</p>
<p>Different from the code above,  we can use upcast, it gets this to compile but a[0] will be wrong value.</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">char</span> a[] = { <span class="hljs-number">0x85</span>, <span class="hljs-number">0x86</span>, <span class="hljs-number">0x87</span>, <span class="hljs-number">0x88</span> };
  <span class="hljs-keyword">int</span> b = a[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">char</span> *p = &amp;a[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">int</span> *q = (<span class="hljs-keyword">int</span> *) p;  <span class="hljs-comment">/* type checker accepts explict cast */</span>
  <span class="hljs-keyword">int</span> c = *q;
  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;b=%08x, c=%08x, p=%p, q=%p\n&quot;</span>, b, c, p, q);
  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;b=%d, c=%d\n&quot;</span>, b, c);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

output:
clang -m32 typing<span class="hljs-number">-02.</span>c &amp;&amp; ./a.out
b=ffffff85, c=<span class="hljs-number">88878685</span>, p=<span class="hljs-number">0x7ffee09a01e8</span>, q=<span class="hljs-number">0x7ffee09a01e8</span>
b=<span class="hljs-number">-123</span>, c=<span class="hljs-number">-2004384123</span>
</code></pre>
<p>In the code,   char pointer *p upcast to int pointer *q, but and store the value of p in variable c. but even it doesn&apos;t get compiler error, the result is wrong.</p>
<ul>
<li><strong>shape error: the same memory location is read and interpreted at an imcompatible type, called unchecked runtime type error</strong><ul>
<li>cause by upcasting, downcasting, <del>unproper assignment</del>(it can be checked when compile time)</li>
<li>shape error are silent and allow access.</li>
</ul>
</li>
</ul>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>* p)</span> </span>{
    *(p+<span class="hljs-number">1</span>) = <span class="hljs-number">0xf0800000</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">float</span> f = <span class="hljs-number">10</span>;    
    <span class="hljs-keyword">int</span> a[]  = { <span class="hljs-number">10</span> };
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;
                <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;f=%f, a[0]=%d i=%d\n&quot;</span>, f, a[<span class="hljs-number">0</span>], i);
    a[<span class="hljs-number">-1</span>] = <span class="hljs-number">47</span>; <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;f=%f, a[0]=%d i=%d\n&quot;</span>, f, a[<span class="hljs-number">0</span>], i);
    update (a); <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;f=%f, a[0]=%d i=%d\n&quot;</span>, f, a[<span class="hljs-number">0</span>], i);
}

output:
clang -m32 typing<span class="hljs-number">-03.</span>c &amp;&amp; ./a.out
f=<span class="hljs-number">10.000000</span> a[<span class="hljs-number">0</span>]=<span class="hljs-number">10</span> i=<span class="hljs-number">10</span>
f=<span class="hljs-number">10.000000</span> a[<span class="hljs-number">0</span>]=<span class="hljs-number">10</span> i=<span class="hljs-number">47</span>
f=<span class="hljs-number">-316912650057057350374175801344.000000</span> a[<span class="hljs-number">0</span>]=<span class="hljs-number">10</span> i=<span class="hljs-number">47</span>
(from high to low: a[<span class="hljs-number">1</span>], a[<span class="hljs-number">0</span>], a[<span class="hljs-number">-1</span>])
</code></pre>
<p>When stack of main has 3 variables, f, a[], and i, when a[-1] is assigned, it change i, and when executing update function, the address of a is as parameter of the function the address a+1 is changed, which original belong to i, so i is changed.</p>
<ul>
<li>strong and weak<ul>
<li>strong type guarantees no shape errors(upcasting or downcasting ,and array problem causes incompatible type)</li>
<li>weak type may permit shape error</li>
</ul>
</li>
</ul>
<pre><code class="lang-text">void unsafeCommand () { printf (&quot;ouch!\n&quot;); }
void safeCommand ()   { printf (&quot;hurray!\n&quot;); }
int guess () { return &amp;unsafeCommand - &amp;safeCommand; }
int main () {
    printf (&quot;%d\n&quot;, guess ());
    void (*c) () = &amp;safeCommand;

    c();
    c += -48;
    c();
}

output:
clang -m32 typing-04.c &amp;&amp; ./a.out
-48
hurray!
ouch!
</code></pre>
<p>UnsafeCommand function print ouch!, safeCommand function print hurray!, guess ,using ouch!-hurray!=-48, the main function print guess() result, which is -48, and save safeCommand function in a pointer c. When invoking function c(), the result is hurray!, and add -48 to c(), the result is ouch!  In this way, if your guess function is correct you could call anything, super unsafe. </p>
<p>&#x1F602;: That is shape error: reading memory in an incompatible type or data used contrary to type. However c is weak type, so it could run and no warning and error message.</p>
<pre><code>void floatCommand (float f) { printf (&quot;f=%f\n&quot;, f); }
void intCommand (int i)     { printf (&quot;i=%d\n&quot;, i); }
int guess () { return &amp;floatCommand - (void (*)(float)) &amp;intCommand; }
int main () {
    printf (&quot;%d\n&quot;, guess ());
    void (*c) (int) = &amp;intCommand;
    int j = 0xf0800000;
    c(j);
    c -= 64;
    c(j);
} 

output:
clang -m32 typing-05.c &amp;&amp; ./a.out
-64
i=-260046848
f=-316912650057057350374175801344.000000
</code></pre><p>function floatCommand take a float number and return, intCommand function take a int and return, guess() return the floatCommand address- upcasting intCommand address. In the main function guess return -64, and j is the number -260046848, intCommand function is store in a pointer c, c take a int number and return correct number, when c is try to become floatCommand, it return an incorrect number.</p>
<ul>
<li>Strong and static language<ul>
<li>Java, C#, Scala, Rust, etc</li>
</ul>
</li>
<li>weak  and static language<ul>
<li>C</li>
</ul>
</li>
<li>Strong and dynamic language<ul>
<li>Scheme, python, ruby, etc</li>
</ul>
</li>
</ul>
<p>&#x1F602;: if a language is static type, it is hard to find upcasting and downcasting causes problem, but dynamic type     is easy to find. To compensate that problem, static type checking language also add dynamic type checking.</p>
<pre><code class="lang-text">class A { int x; }
class B extends A { float y; }
class C extends A { char c; }

class Typing02 {
  public static void main (String[] args) {
    B b = new B ();
    A a = b;
    C c = (C) a;
  }
}

output:
javac Typing02.java &amp;&amp; java Typing02
Exception in thread &quot;main&quot; java.lang.ClassCastException: B cannot be cast to C
</code></pre>
<p>B and C extends A, So, B and C type object could upcast to A type, and A type Object could downcast to B and C type. In the main function, b is B type object and upcast to A type, then downcast to a type.  What we know is Java is static type language, but the exception message indicate Java also have dynamic type checking to make sure it was a C type before , thus, it could find a downcast to a is wrong.</p>
<p>Java doesn&apos;t allow shape error, so it is strong type. Java&apos;s type checking is mostly static, runtime tests for only in certain cases.</p>
<ul>
<li>java dynamic checks in java </li>
</ul>
<pre><code class="lang-text">class A { int x; }
class B extends A { float y; }
class C extends A { char c; }

class Typing03 {
  public static void main (String[] args) {
      B[] bs = new B[1];
      A[] as = bs;
      as[0] = new C();
      B b = bs[0];
  }
}

output:
javac Typing03.java &amp;&amp; java Typing03
Exception in thread &quot;main&quot; java.lang.ArrayStoreException: C
</code></pre>
<p>the main function create a new array, B type with 2 length,  and upcast array to A type, as[0] is the first cell are defined to C type, it is not allowed, and set b to bs[0],which is as[0].One array contains two type of element, which is not allowed.</p>
<pre><code class="lang-text">class A { int x; }
class B extends A { float y; }
class C extends A { char c; }

class Typing04 {
  public static void main (String[] args) {
    B[] bs = new B[4];
    C c = new C();
    B b = bs[-1];
  }  
}

output:
javac Typing04.java &amp;&amp; java Typing04
Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: -1
</code></pre>
<p>Class B and C extend Class A. In main function,  A b type array are initialized,  and a variable c is c type, b  is bs[-1], which is out of the bound of array bs. </p>
<pre><code class="lang-text">class A { int x; }
class B extends A { float y; }
class C extends A { char c; }

class Typing05 {
  static void f (B b) {
    A a = b;       // upcast
  }
  static void g (A a) {
    B b = (B) a;   // downcast
  }
  public static void main (String[] args) {
      f (new B());
      g (new C());
  }  
}

output:
javac Typing05.java &amp;&amp; java Typing05
Exception in thread &quot;main&quot; java.lang.ClassCastException: C cannot be cast to B
</code></pre>
<p>function f is for upcasting, function g is for downcasting. In the main, g take a C type  parameter treated as A type, and down casting to B type, it is not allowed.</p>
<ul>
<li><p>&#x1F602; dynamic checking in java: what is checking for? </p>
<ul>
<li>the error which is not syntax error and not operator error which static checking could detected</li>
<li>such as array out of bounds exception, dividing 0 exception, stack overflow or array overflow exception, which is not error but will cause problem. In c it is called undefined behavior.</li>
</ul>
</li>
<li><p>&#x1F602; Why java restrict use of pointers, instead using garbage collection?</p>
<ul>
<li>if use pointer, user have to free the memory to deallocate, which will reuse the memory using before and cause safety problem.</li>
</ul>
</li>
</ul>
<h4 id="scala-introduction">Scala introduction</h4>
<ul>
<li>Scala&#xFF1A; functional and object-oriented PL<ul>
<li>Boolean, numeric, and string</li>
<li>static type checking</li>
</ul>
</li>
<li>variable:<ul>
<li>immutable variable: val x=10</li>
<li>mutable variable: var x=10</li>
</ul>
</li>
<li>expression oriented:no statements, like scheme, ML, etc</li>
<li>comma expression:{e_1;e_2;e_3...;e_n} or {e_1 e_2 e_3... e_n}</li>
<li>method&#xFF1A;<ul>
<li>def plus(x:Int, y:Int): Int=x+y</li>
<li>def also could use to define global variable</li>
</ul>
</li>
<li>Object: everything is object in Scala<ul>
<li>5.toDouble</li>
<li>5.+(5) or 5+6</li>
<li>5.max(6) or 5 max 6</li>
</ul>
</li>
<li>tuple: Immuable<ul>
<li>val x:(Int, String)=(5,&quot;hello&quot;)</li>
</ul>
</li>
<li>Linked List:varying number of homogeneous items<ul>
<li>(cons 1(cons 2 ()))</li>
<li>1&#xFF1A;&#xFF1A;&#xFF08;2&#xFF1A;&#xFF1A;Nil&#xFF09;</li>
<li>List&#xFF08;1&#xFF0C;2&#xFF0C;3&#xFF09;</li>
<li>xs.head; xs.tail</li>
<li>wrong mistake: xs(1)=7</li>
</ul>
</li>
<li>pattern matching</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-comment">//pattern matching</span>
<span class="hljs-keyword">val</span> p : (<span class="hljs-type">Int</span>, <span class="hljs-type">String</span>) = <span class="hljs-comment">// ...</span>
p <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> (x, y) =&gt; <span class="hljs-string">&quot;Int is %d&quot;</span>.format (x)
}
</code></pre>
<pre><code class="lang-text">val xs : List[Int] = // ...
xs match {
  case Nil   =&gt; &quot;List is empty&quot;
  case y::ys =&gt; &quot;List is non-empty, head is %d&quot;.format (y)
}
</code></pre>
<p>recursive function</p>
<ul>
<li>functional programming has immutable programming, which is different from regular programming</li>
<li>wildcard_:relative ignore head</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-comment">// length: input a list,return a int</span>
<span class="hljs-comment">//count</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>]) : <span class="hljs-type">Int</span> = xs <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; <span class="hljs-number">0</span>
  <span class="hljs-keyword">case</span> _::ys =&gt; <span class="hljs-number">1</span> + length (ys)
}
</code></pre>
<ul>
<li>List build in appending function</li>
<li>(:::):append between list and list</li>
<li>(::): append between element and list</li>
</ul>
<h3 id="worksheet">worksheet</h3>
<h3 id="homework">homework</h3>
<h3 id="quiz">quiz</h3>
<h2 id="lecture3">Lecture3</h2>
<h3 id="class-notes">class notes</h3>
<h4 id="background-knowledgeparametric-polymorphism">background knowledge:parametric polymorphism</h4>
<ul>
<li>&#x1F602;why using generic type: for no need to overload one function for every type of parameter, the object in java could be used, but when specify type, we have to downcast and downcasting will cause shape error, so Java create generic type.</li>
<li>generic linked list in C</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">//Use (void *) type in C</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> node_int_ptr node_int_ptr;

<span class="hljs-keyword">struct</span> node_int_ptr {
  <span class="hljs-keyword">int</span> *item;
  node_int_ptr *next;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length_while_int_ptr</span> <span class="hljs-params">(node_int_ptr *xs)</span> </span>{
  <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (xs) {
    result += <span class="hljs-number">1</span>;
    xs = xs-&gt;next;
  }
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>Use <code>(void *)</code> type in C,Can cast/store any pointer type at type <code>(void *)</code>But it must cast from <code>(void *)</code> before dereferencing. Problem on downcasting, which will cause shape error.</p>
<ul>
<li>generic type in Java<ul>
<li>problem: Downcasting will cause shape error but never reach shape error</li>
</ul>
</li>
</ul>
<pre><code class="lang-java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{
  Object item;
  Node next;
}

Node xs = ...           <span class="hljs-comment">// filled with java.io.InputStream elements</span>
Object p = xs.item;     <span class="hljs-comment">// OK</span>
String q = (String) p;  <span class="hljs-comment">// runtime ClassCastException halts execution</span>
q.endsWith (<span class="hljs-string">&quot;a&quot;</span>);       <span class="hljs-comment">// never reach shape error</span>
</code></pre>
<ul>
<li>the right generic type: could use any type as parameter and don&apos;t need to downcast</li>
</ul>
<pre><code class="lang-java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">X</span>&gt; </span>{
  X item;
  Node&lt;X&gt; next;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span> <span class="hljs-params">(X item, Node&lt;X&gt; next)</span> </span>{ 
    <span class="hljs-keyword">this</span>.item = item; 
    <span class="hljs-keyword">this</span>.next = next; 
  }
}

<span class="hljs-keyword">static</span> &lt;X&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span> <span class="hljs-params">(Node&lt;X&gt; xs)</span> </span>{
  <span class="hljs-keyword">if</span> (xs == <span class="hljs-keyword">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  } <span class="hljs-keyword">else</span> { 
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + length (xs.next);
  }
}
</code></pre>
<h4 id="function-programming">function programming</h4>
<ul>
<li>function and method</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span> </span>(x:<span class="hljs-type">Int</span>) = x + <span class="hljs-number">1</span>; <span class="hljs-comment">//method a</span>
<span class="hljs-keyword">val</span> b = (x:<span class="hljs-type">Int</span>) =&gt; x + <span class="hljs-number">1</span>; <span class="hljs-comment">//anonymous function</span>
<span class="hljs-keyword">val</span> c : (<span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span>) = (x) =&gt; x + <span class="hljs-number">1</span>;<span class="hljs-comment">// anonymous function with a parameter x</span>
<span class="hljs-keyword">val</span> d = <span class="hljs-keyword">new</span> <span class="hljs-type">Function</span>[<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>] { <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(x:<span class="hljs-type">Int</span>) = x + <span class="hljs-number">1</span> } <span class="hljs-comment">// function oject with apply method</span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">e</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Function1</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>] </span>{ <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(x:<span class="hljs-type">Int</span>) = x + <span class="hljs-number">1</span>; }
<span class="hljs-keyword">val</span> f : <span class="hljs-type">PartialFunction</span>[<span class="hljs-type">Any</span>, <span class="hljs-type">Int</span>]  = { <span class="hljs-keyword">case</span> i: <span class="hljs-type">Int</span> &#x21D2; i + <span class="hljs-number">1</span> }
</code></pre>
<p>function is an object, when executing function, function are implemented as object with method apply,  aka function will convert to method and execute(function.apply()) .method is just method. </p>
<ul>
<li>Build-in function use<ul>
<li>for each is new control structure for list, based on for each to improve other function</li>
<li>foreach, sum, transform, map, identity,filter</li>
</ul>
</li>
<li>recursion, function could be a parameter, own function<ul>
<li>pass named function(printElt) to foreach: foreach (xs, printElt)<ul>
<li>xs.foreach((x:X)=&gt;println(x))</li>
<li>foreach(xs,(x:X)=&gt;println(x))</li>
</ul>
</li>
<li>pass anonymous function to foreach:foreach (xs, (x:Int) =&gt; println (&quot;%02d&quot;.format(x)))</li>
</ul>
</li>
<li>foldleft and foldright understanding<ul>
<li>sum to foldleft: use tail recursion</li>
</ul>
</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(xs:<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>],z:<span class="hljs-type">Int</span>=<span class="hljs-number">0</span>): <span class="hljs-type">Int</span>=&gt;{
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>=&gt;<span class="hljs-type">Nil</span>
    <span class="hljs-keyword">case</span> y::ys=&gt; sum(ys,y+z)
}
<span class="hljs-keyword">val</span> xs = <span class="hljs-type">List</span>(<span class="hljs-number">11</span>,<span class="hljs-number">21</span>,<span class="hljs-number">31</span>)
sum (xs)
</code></pre>
<ul>
<li><ul>
<li>FoldLeft: tail recursion</li>
</ul>
</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldleft</span> </span>[<span class="hljs-type">Z</span>,<span class="hljs-type">X</span>](z:<span class="hljs-type">Z</span>,xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>],f((<span class="hljs-type">Z</span>,<span class="hljs-type">X</span>)=&gt;<span class="hljs-type">Z</span>)): <span class="hljs-type">Z</span>=&gt;{
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>=&gt;<span class="hljs-type">Nil</span>
    <span class="hljs-keyword">case</span> y::ys=&gt;foldleft(f(z,y),ys,f)
}
foldleft(<span class="hljs-number">0</span>,xs,(z:<span class="hljs-type">Int</span>,x:<span class="hljs-type">Int</span>)=&gt;z+x)
</code></pre>
<ul>
<li><ul>
<li>sum to foldright:non-tail recursion</li>
</ul>
</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum2</span> </span>(xs:<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>],z:<span class="hljs-type">Int</span>=<span class="hljs-number">0</span>):<span class="hljs-type">Int</span>=&gt;{
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>=&gt;<span class="hljs-type">Nil</span>
    <span class="hljs-keyword">case</span> y::ys=&gt;y+sum(ys,z)
}
<span class="hljs-keyword">val</span> xs = <span class="hljs-type">List</span>(<span class="hljs-number">11</span>,<span class="hljs-number">21</span>,<span class="hljs-number">31</span>)
sum (xs)
</code></pre>
<ul>
<li><ul>
<li>FoldRight: non-tail recursion</li>
</ul>
</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldright</span> </span>[<span class="hljs-type">Z</span>,<span class="hljs-type">X</span>] (z:<span class="hljs-type">Z</span>,xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>],f(<span class="hljs-type">Z</span>,<span class="hljs-type">X</span>)=&gt;<span class="hljs-type">Z</span>):<span class="hljs-type">Z</span>={
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>=&gt;<span class="hljs-type">Nil</span>
    <span class="hljs-keyword">case</span> y::ys=&gt;f(z,foldright(z,ys,f))
}
foldright(<span class="hljs-number">0</span>,xs,(z:<span class="hljs-type">Int</span>,x:<span class="hljs-type">Int</span>)=&gt;z+x)
</code></pre>
<ul>
<li><ul>
<li>foldleft and foldright:<ul>
<li><code>foldLeft</code> is tail recursive: each iteration applies <code>f</code> to the next value and the accumulated result; recursive call is the result</li>
<li><code>foldRight</code> is recursive into an argument: each iteration applies <code>f</code> to the next value and the result of recursively folding the rest of the list</li>
</ul>
</li>
</ul>
</li>
<li>buildin folds<ul>
<li>xss.foldLeft (0) ((z,xs)=&gt;z + xs.length)</li>
<li>xss.foldLeft(0)(f) == (0 /: xss)(f) :foldLeft (xs, z, f) === f( f( f( f(z, a), b), c))</li>
<li>xss.foldRight(0)(f) == (xss :\ 0)(f):foldRight(xs, z, f) === f(a, f(b, f(c, z)))</li>
</ul>
</li>
<li>&#x1F602;<ul>
<li>foldleft:xs:(a,b,c)=&gt;z+a+b+c..</li>
<li>foldright:xs(a,b,c)=&gt;z+..+c+b+a</li>
</ul>
</li>
<li>currying<ul>
<li>xss.foldLeft (z, f)=&gt;xss.foldLeft (z) (f)</li>
</ul>
</li>
<li>high order function<ul>
<li><code>foreach</code>, <code>map</code>, <code>filter</code> are higher-order functions, because they take other functions as arguments</li>
</ul>
</li>
<li>functional programming<ul>
<li>function are first class,create/passed as runtime,sometime sides effct is banned</li>
<li>first class: declared with in any scope, pass as a arguments to other functions, returns as result of functions</li>
</ul>
</li>
<li>object oriented programming<ul>
<li>objects are first class,create/passed at runtime</li>
</ul>
</li>
</ul>
<h4 id="for-expression">for expression</h4>
<ul>
<li>set comprehensions<ul>
<li>{(m,n)|m{0,..,10}^n{0..,10}^m&lt;=n}</li>
</ul>
</li>
<li>for (x &lt;- xs) sum = sum + x</li>
<li>map or foreach and for expression $$a = b$$ <ul>
<li>for(x&lt;-xs) e===xs.foreach((x)=&gt;e)</li>
<li>for (x &lt;- xs) yield e === xs.map ((x)=&gt;e)</li>
</ul>
</li>
<li>conditional for expression<ul>
<li>for(x&lt;-xs;if(x%2!=0)) yield(2*x)</li>
</ul>
</li>
<li>flatten operation and for expression</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatten</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-type">X</span>]]) : <span class="hljs-type">List</span>[<span class="hljs-type">X</span>] = xs <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; <span class="hljs-type">Nil</span>
  <span class="hljs-keyword">case</span> y::ys =&gt; y ::: flatten(ys)
}
</code></pre>
<ul>
<li>(for (xs &lt;- xss; x &lt;- xs) yield x) == (1 to 10).toList<ul>
<li>flatten function is same to for look version above, which  take a list of list and return a list of element.</li>
</ul>
</li>
</ul>
<h4 id="option-type">option type</h4>
<ul>
<li>Type-safe and principled approach to missing data<ul>
<li>Example of option type[Int]: None,  Some(5)</li>
</ul>
</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-comment">//safeDivide: input m and n and return m/n, the special case is when n=0, thus, using</span>
<span class="hljs-comment">//option type to make sure every situation is safe.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">safeDivide</span> </span>(m:<span class="hljs-type">Int</span>, n:<span class="hljs-type">Int</span>) : <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = {
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) 
    <span class="hljs-type">None</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-type">Some</span> (m / n)
}
</code></pre>
<ul>
<li>&#x1F602;why : key is return a &quot;none&quot; value when it is needed, for example, when m/n &amp;&amp; n=0</li>
<li>Java deal with this : Java will throw a exception when m/n and n==0</li>
<li>when: <ul>
<li>distinguish value one same type.<ul>
<li>-1 for bytes read</li>
<li>null reference for reference type: C c=new C()</li>
<li>NULL pointer for pointers types: a[-1]</li>
</ul>
</li>
<li>exceptions</li>
</ul>
</li>
<li>example</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span></span>[<span class="hljs-type">X</span>](xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>],n:<span class="hljs-type">Int</span>):<span class="hljs-type">Option</span>[<span class="hljs-type">X</span>]=&gt; {
    xs <span class="hljs-keyword">match</span>{
        <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>=&gt;<span class="hljs-type">None</span>
        <span class="hljs-keyword">case</span> y::_=&gt;<span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>=&gt;<span class="hljs-type">Some</span>(y)
        <span class="hljs-keyword">case</span> _::ys=&gt; index(ys,n<span class="hljs-number">-1</span>)
    }
}
</code></pre>
<ul>
<li>option type and null<ul>
<li>option type have something or nothing(two possibility)</li>
<li>scala types represent nothing<ul>
<li>Nil: empty list</li>
<li>None: empty option</li>
<li>None: reference to nonthing</li>
<li>Unit: return nothing, same to Java void</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="worksheet">worksheet</h3>
<h3 id="homework">homework</h3>
<h3 id="quiz">quiz</h3>
<h2 id="lecture4">Lecture4</h2>
<h3 id="class-notes">class notes</h3>
<h4 id="scheme-loops">Scheme loops</h4>
<ul>
<li>with an incrementing counter argument n</li>
</ul>
<pre><code class="lang-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> loop ([<span class="hljs-name">n</span> <span class="hljs-number">0</span>])
  (<span class="hljs-name"><span class="hljs-builtin-name">display</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">string-append</span></span> <span class="hljs-string">&quot;hello &quot;</span> (<span class="hljs-name"><span class="hljs-builtin-name">number-&gt;string</span></span> n) <span class="hljs-string">&quot;\n&quot;</span>))
  (<span class="hljs-name">loop</span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> n <span class="hljs-number">1</span>)))
</code></pre>
<h4 id="tail-recursion">Tail recursion</h4>
<ul>
<li>&#x1F602;why need to use tail recursion?<ul>
<li>stack:contain activation records(AR) for active calls, AKA stack frames</li>
<li>why call stack:AR pushed when a function/method call is made, AR popped when a function/method returns</li>
<li>runtime environment limit size of call stack, which will cause problem with deep recursion</li>
<li>stack overflow: c,OS,scheme, Java, Scala</li>
</ul>
</li>
<li>tail call optimization<ul>
<li>recursive function return before next recursive function start</li>
<li>recursive call must be tail recursive</li>
</ul>
</li>
<li>what:the last step of method is recursive without other operation, thus is tail recursion.</li>
</ul>
<h4 id="scala-classes">Scala classes</h4>
<ul>
<li>scala support both FP and OOP</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-comment">//scala FP</span>
(<span class="hljs-number">0</span> to <span class="hljs-number">9</span>).toList.partition ((x:<span class="hljs-type">Int</span>) =&gt; x%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">//</span>
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//scala OOP</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{ <span class="hljs-comment">//define a class</span>
  <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>  <span class="hljs-comment">//define a field</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span> </span>() : <span class="hljs-type">Int</span> = { <span class="hljs-keyword">val</span> tmp = n; n = n + <span class="hljs-number">1</span>; tmp } <span class="hljs-comment">//define a method</span>
}

<span class="hljs-keyword">val</span> c = <span class="hljs-keyword">new</span> <span class="hljs-type">Counter</span>  <span class="hljs-comment">//create an object and using object to call function</span>
c.get
c.get
</code></pre>
<ul>
<li>class parameters<ul>
<li>constructor :<code>class C (f1:Int, val f2:Int, var f3:Int) { ... }</code><ul>
<li><code>(f1:Int):</code> private val f1(immutable)</li>
<li><code>(val f2:Int):</code> public val f2(immutable)</li>
<li><code>(var f3:Int):</code> public var f3(mutable)</li>
</ul>
</li>
<li>How to prove private<ul>
<li>if <em>**</em>other class(not in C) cannot call f1, c.f1 shows error message. The value have to be obtained by  get method.</li>
</ul>
</li>
<li>How to prove immutable<ul>
<li>if change the field to other number, c.f2=10 then c.f2=3 will shows error message</li>
</ul>
</li>
</ul>
</li>
<li>class body<ul>
<li><code>class D (f1:Int)</code></li>
</ul>
</li>
<li>companion objects<ul>
<li>In JAVA</li>
</ul>
</li>
</ul>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>{
  <span class="hljs-keyword">int</span> f1;
  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">m1</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> f1; }
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> f2; <span class="hljs-comment">// static field</span>
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">m2</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> f2; } <span class="hljs-comment">//static function</span>
}
</code></pre>
<ul>
<li><ul>
<li>In Scala</li>
</ul>
</li>
</ul>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>{
  var f1:<span class="hljs-function">Int
  def <span class="hljs-title">m1</span> <span class="hljs-params">()</span> : Int </span>= f1
}
<span class="hljs-comment">// this part is static field and function</span>
object C {
  var f2:<span class="hljs-function">Int
  def <span class="hljs-title">m2</span> <span class="hljs-params">()</span> : Int </span>= f2
}
</code></pre>
<ul>
<li><ul>
<li>the object can only appear when following class, and only one instance of object declarations</li>
</ul>
</li>
<li>Singleton in java and scala<ul>
<li>singleton is for creating only one object, and other class could use the only one object<ul>
<li>private construction so that other class cannot create object of  this class, only themselves can create</li>
<li>private static field, singleton type, which is the object, this only object, static so other class can use the only object</li>
<li>public static getInstance function to new object so that other class could use class name to invoke method</li>
</ul>
</li>
<li>in java</li>
</ul>
</li>
</ul>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Point p;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;
    <span class="hljs-function">prviate <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
     <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number">10</span> &amp;&amp; <span class="hljs-number">0</span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number">10</span>){
         <span class="hljs-keyword">this</span>.x=x;
         <span class="hljs-keyword">this</span>.y=y;
      }
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Point <span class="hljs-title">getInstance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
        <span class="hljs-keyword">if</span>(p==<span class="hljs-keyword">null</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Point(x, y);
        }
        <span class="hljs-keyword">return</span> p;
    }
    <span class="hljs-comment">//other methods..</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">translate</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> xDisp,<span class="hljs-keyword">int</span> yDisp)</span></span>{
    x=x+xDisp;
    y=y+yDisp;
    }
}
</code></pre>
<ul>
<li>in scala</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-title">private</span> (<span class="hljs-params">private var x:<span class="hljs-type">Int</span>, private var y:<span class="hljs-type">Int</span></span>) </span>{<span class="hljs-comment">//private constructor and field</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">translate</span> </span>(xDisp:<span class="hljs-type">Int</span>, yDisp:<span class="hljs-type">Int</span>) : <span class="hljs-type">Unit</span> = { 
    x = x + xDisp
    y = y + yDisp
  }
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Point</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span> </span>(x:<span class="hljs-type">Int</span>, y:<span class="hljs-type">Int</span>) : <span class="hljs-type">Point</span> = {
    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number">10</span> &amp;&amp; <span class="hljs-number">0</span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number">10</span>) {
      <span class="hljs-keyword">new</span> <span class="hljs-type">Point</span> (x, y)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span> (<span class="hljs-string">&quot;invalid params&quot;</span>)
    }
  }
}
</code></pre>
<h4 id="algebraic-data-types">Algebraic data types</h4>
<ul>
<li>algebraic data types<ul>
<li>product types: tuples</li>
<li>sum types: tagged union</li>
<li>eg: option type, list type</li>
</ul>
</li>
<li>product type:tuple, can combine two different type of varible<ul>
<li>Named for Cartesian product of sets: X * Y = { (x, y) | x &#x2208; X &#x2227; y &#x2208; Y }</li>
<li>case class: case class C(x:Int,y:String); val c= C(5,&quot;hello&quot;)</li>
<li>pattern match:</li>
</ul>
</li>
</ul>
<pre><code class="lang-text">val n:Int = c match { 
  case C (a, b) =&gt; a
}
</code></pre>
<ul>
<li>How compiler treat for case class?</li>
</ul>
<pre><code class="lang-text">case class C (x:Int, y:String)
val c:C = C (5, &quot;hello&quot;)
val a:Int = c.x
c.x = 6 // error: reassignment to val
</code></pre>
<ul>
<li>argument is immutable and visible, generate companion object with apply method</li>
<li><ul>
<li>set union<ul>
<li>Cartesian product of sets: X * Y = { (x, y) | x &#x2208; X &#x2227; y &#x2208; Y }</li>
<li>union of sets: X &#x222A; Y = { z | z &#x2208; X &#x2228; z &#x2208; Y }</li>
<li>Coproduct or disjoint union of sets: X &#x2295; Y = X &#x228D; Y = { (0, x) | x &#x2208; X } &#x222A; { (1, y) | y &#x2208; Y }</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DateSpecifier</span> <span class="hljs-title">//</span> <span class="hljs-title">interface</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Absolute</span> (<span class="hljs-params">year:<span class="hljs-type">Int</span>,mon:<span class="hljs-type">Int</span>,day:<span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">DateSpecifier//</span> <span class="hljs-title">a</span> <span class="hljs-title">class</span> <span class="hljs-title">implements</span> <span class="hljs-title">interface</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Relative</span> (<span class="hljs-params">daysOffset:<span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">DateSpecifier//</span> <span class="hljs-title">another</span> <span class="hljs-title">class</span> <span class="hljs-title">implements</span> <span class="hljs-title">interface</span></span>

<span class="hljs-keyword">val</span> ds = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">DateSpecifier</span>] (<span class="hljs-number">2</span>) <span class="hljs-comment">//create an array</span>
ds (<span class="hljs-number">0</span>) = <span class="hljs-type">Absolute</span> (<span class="hljs-number">2030</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// Months are 0.11 // first is absolute type</span>
ds (<span class="hljs-number">1</span>) = <span class="hljs-type">Relative</span> (<span class="hljs-number">-5</span>) <span class="hljs-comment">//second is relative type</span>
</code></pre>
<ul>
<li>recursive types</li>
</ul>
<pre><code class="lang-text">//peano natural number
trait PeanoNat
case object Zero              extends PeanoNat
case class  Succ (n:PeanoNat) extends PeanoNat
</code></pre>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">List</span>[+<span class="hljs-type">X</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Nil</span>                             <span class="hljs-keyword">extends</span> <span class="hljs-title">List</span>[<span class="hljs-type">Nothing</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Cons</span>[+<span class="hljs-type">X</span>] (<span class="hljs-params">head:<span class="hljs-type">X</span>, tail:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">List</span>[<span class="hljs-type">X</span>]</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">length</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>]): <span class="hljs-type">Int</span> = xs <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-number">0</span>
  <span class="hljs-keyword">case</span> <span class="hljs-type">Cons</span>(a,as) =&gt; <span class="hljs-number">1</span> + length(as)
}
length (<span class="hljs-type">Cons</span> (<span class="hljs-number">1</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Nil</span>)))
</code></pre>
<pre><code class="lang-text">trait Tree[+X]
case object Leaf                                 extends Tree[Nothing]
case class  Node[+X] (l:Tree[X], c:X, r:Tree[X]) extends Tree[X]
</code></pre>
<ul>
<li>&#x1F602;: a interface has two  kind of format. For list, there are Nil and Cons. For tree, there are leaf,which has no data stored at leave and node, which data tored in interval nodes and left node and right node are tree too </li>
</ul>
<h3 id="worksheet">worksheet</h3>
<h3 id="homework">homework</h3>
<h3 id="quiz">quiz</h3>
<h2 id="lecture5">Lecture5</h2>
<h3 id="class-notes">class notes</h3>
<h4 id="scope-and-lifetime">scope and lifetime</h4>
<ul>
<li>scope of indentifer: region of text in which it may be used</li>
<li>common rule: local variable scope is start declaration, end until the curly bracket.</li>
<li>occurrence: occurrence situation in scope<ul>
<li>free occurrence:<ul>
<li>y=5*x</li>
</ul>
</li>
<li>binding occurrence:<ul>
<li>int y</li>
</ul>
</li>
<li>bound occurrence:<ul>
<li>int y; int x; x=6; y=5*x;</li>
</ul>
</li>
</ul>
</li>
<li>different possible chance to use variable:<ul>
<li>normal variable, function parameters, function type parameterer(return value)</li>
<li>function name: int x= a function</li>
<li>class name</li>
<li>and more</li>
</ul>
</li>
<li>forward declaration<ul>
<li>shadowing allowed in c and c++</li>
</ul>
</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">// f is defined before, but defined twice after g, so g may shadowed first f.</span>
<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">g</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">return</span> f (x) + f (x);
}

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) { 
    <span class="hljs-keyword">return</span> g (x &gt;&gt; <span class="hljs-number">8</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }
}
</code></pre>
<ul>
<li>shadowing:<ul>
<li>shadowing is not allow in java </li>
</ul>
</li>
</ul>
<pre><code class="lang-java"><span class="hljs-comment">//x is defined but defined inside scope</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;
    {
      <span class="hljs-keyword">int</span> y = x + <span class="hljs-number">1</span>;
      {
        <span class="hljs-keyword">int</span> x = y + <span class="hljs-number">1</span>;
        System.out.println (<span class="hljs-string">&quot;x = &quot;</span> + x);
      }
    }
  }
}
$ javac C.java 
C.java:<span class="hljs-number">7</span>: error: <span class="hljs-function">variable x is already defined in method <span class="hljs-title">f</span><span class="hljs-params">()</span>
        <span class="hljs-keyword">int</span> x </span>= y + <span class="hljs-number">1</span>;
            ^
<span class="hljs-number">1</span> error
</code></pre>
<ul>
<li><ul>
<li>but field can be shadowed</li>
<li>scala is less strict than java, and shadowing occurs in REPL naturally</li>
<li>Althought in c variable can be shadowing, but int x=x+1 are undefined behavior.</li>
</ul>
</li>
<li>Lifetime of an area of memory: duration during which it is allocated<ul>
<li>lifetime and scope: lifetime is the duration in storage(like stack) scope is duration in code part</li>
</ul>
</li>
<li>storage option<ul>
<li>global(static):available for lifetime of program</li>
<li>AR(stack):available while function active</li>
<li>heap: avaible until deallocate</li>
</ul>
</li>
<li>lifetime problem:<ul>
<li>lifetime is too short:<ul>
<li>cause:read return other value</li>
<li>overwrite</li>
<li>incorrect</li>
<li>seurity problem</li>
</ul>
</li>
<li>lifetime is too long:<ul>
<li>use too much memory</li>
<li>too late in freeing other resources</li>
</ul>
</li>
<li>Stack discipline<ol>
<li>(call f) allocate AR for f</li>
<li>(call g) allocate AR for g</li>
<li>(return from g) deallocate AR for g</li>
<li>(return from f) deallocate AR for f</li>
</ol>
</li>
</ul>
</li>
<li>multiple threads<ul>
<li>each thread needs a separate call stack</li>
<li>call and return in separate threads are independent</li>
</ul>
</li>
<li>Heap allocation can use other patterns<ol>
<li>allocate M bytes</li>
<li>allocate N bytes</li>
<li>deallocate M bytes</li>
<li>deallocate N bytes</li>
</ol>
</li>
<li>common problem<ul>
<li>PLs with garbage collection&#xFF08;For Java, Scala, C#, Python, Ruby, JS, Scheme, etc.&#xFF09;<ul>
<li>lifetime too long (not GCed)</li>
</ul>
</li>
<li>PLs with manual memory management (C, C++)<ul>
<li>pointers to storage whose lifetime has ended<ul>
<li>dangling pointers to an old AR</li>
<li>dangling pointers to <code>free</code>d heap memory  (use after free)</li>
<li>double <code>free</code>ing of heap memory</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>dangling pointer problem</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">// dangling pointer-stack: when f(1) return,free f,*p is pointer to freeed erea of y&apos;s address.</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">int</span> y = x;
  <span class="hljs-keyword">return</span> &amp;y;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">int</span> *p = f (<span class="hljs-number">1</span>);
  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;*p = %d\n&quot;</span>, *p);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code class="lang-c"><span class="hljs-comment">//not dangling pointer: when f(1) execute,result is allocated in heap, when function return, </span>
<span class="hljs-comment">//value on heap is on there, p pointer to heap result value and print result value and return 0;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">int</span> *result = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">int</span>));
  *result = x;
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">int</span> *p = f (<span class="hljs-number">1</span>);
  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;*p = %d\n&quot;</span>, *p);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<pre><code class="lang-c"><span class="hljs-comment">//dangling pointer-heap: result on heap is be freed before print</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">int</span> *result = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">int</span>));
  *result = x;
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">int</span> *p = f (<span class="hljs-number">1</span>);
  <span class="hljs-built_in">free</span> (p);
  <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;*p = %d\n&quot;</span>, *p);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h4 id="closures">closures</h4>
<ul>
<li>runtime support for nested function <ul>
<li>nested function declarations not allowed in C</li>
</ul>
</li>
<li>why nested function?<ul>
<li>Inner functions may be anonymous, sometimes aids clarity</li>
<li>Access variables from enclosing context<ul>
<li>avoid duplicating parameters</li>
<li>requires some runtime support</li>
</ul>
</li>
<li>potential problem<ul>
<li>inner function have same variable name with outer function</li>
<li>scope of inner function and outer function</li>
</ul>
</li>
<li>why has this problem?<ul>
<li>when inner function is called, outer function still allocation, but when inner function return inner function cannot variable cannot be reached</li>
<li>when inner function are used twice, and using reference to remember that value, the first time outer function variable may be deallocated and cover by other value. This because stack deallocate after first time return.<ul>
<li>solve:block copy and block release, copy g to heap to keep function variable</li>
</ul>
</li>
</ul>
</li>
<li>need solve:<ul>
<li>inner function how to reach out function?<ul>
<li>inner function block can reach outer variable, because outer function doesn&apos;t  deallocate</li>
</ul>
</li>
</ul>
</li>
<li>scala work well in the problem<ul>
<li>because, instead of block copy, scala has closures to store, which is same to object.</li>
</ul>
</li>
<li>closure<ul>
<li>Closures store inner function and environment</li>
<li>Environment contains variables from enclosing scope</li>
<li>Lifetime of environment = lifetime of inner function<ul>
<li>environment is allocated on the heap</li>
</ul>
</li>
<li>environment has a mutable variable<ul>
<li>Closure contains<ul>
<li>pointer/reference to code for <code>inner</code></li>
<li>copy of <code>x</code></li>
<li>reference to shared <code>u</code> (on heap)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer</span> </span>(x:<span class="hljs-type">A</span>) : <span class="hljs-type">B</span>=&gt;<span class="hljs-type">C</span> = {
  <span class="hljs-keyword">var</span> u:<span class="hljs-type">A</span> = x
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span> </span>(y:<span class="hljs-type">B</span>) : <span class="hljs-type">C</span> = {
    ...use u and y...
  }
  u = u + <span class="hljs-number">1</span>
  inner
}
</code></pre>
<ul>
<li>example</li>
</ul>
<pre><code class="lang-text">val f:()=&gt;Int = {var x= -1; () =&gt; { x = x + 1; x}}
val g:Int=&gt;()=&gt;Int = (y) =&gt; {var z= y; () =&gt; { z = z + 1; z}}
</code></pre>
<ul>
<li>problem of closure function:<ul>
<li>how to safely save the result? because the value diappear with the stack storage<ul>
<li>in c, it stores in block, which is heap;in scala, it stores in closure</li>
</ul>
</li>
<li>if a variable in outer function is mutable, inner function need to use it and change it, how to do it?<ul>
<li>closure contain this variable as reference, shared with outer function and inner function.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="worksheet">worksheet</h3>
<h3 id="homework">homework</h3>
<h3 id="quiz">quiz</h3>
<h2 id="lecture6midterm">Lecture6:midterm</h2>
<h3 id="class-notes">class notes</h3>
<h4 id=""> </h4>
<h3 id="orksheet">orksheet</h3>
<h3 id="homework">homework</h3>
<h3 id="quiz">quiz</h3>
<h2 id="lecture7">Lecture7</h2>
<h3 id="class-notes">class notes</h3>
<h4 id="nested-class">nested class</h4>
<pre><code class="lang-java"><span class="hljs-comment">//interface has a apply function, taking t and return u</span>
<span class="hljs-comment">//class c has a function f, return I type, inside the function, create a I type object and</span>
<span class="hljs-comment">// inside I, there a function override function in I ,which is an anonymous inner class.</span>
<span class="hljs-comment">//it actually is  a closure and can use x and t. and then return I</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">I</span> </span>{
  <span class="hljs-function">U <span class="hljs-title">apply</span> <span class="hljs-params">(T t)</span></span>; <span class="hljs-comment">// for some types T and U</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>{
  <span class="hljs-function">I <span class="hljs-title">f</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
    I a = <span class="hljs-keyword">new</span> I () { <span class="hljs-comment">// new instance of anonymous class implementing I</span>
      <span class="hljs-function"><span class="hljs-keyword">public</span> U <span class="hljs-title">apply</span> <span class="hljs-params">(T t)</span> </span>{ 
        <span class="hljs-comment">// can use x from enclosing scope, and t parameter</span>
      }
    };
    <span class="hljs-keyword">return</span> a;
  }
}
</code></pre>
<ul>
<li>we can bring it out</li>
</ul>
<pre><code class="lang-text">interface I {
  U apply (T t); // for some types T and U
}

class D implements I {
  final int x;              
  D (int x) { this.x = x; } 
  public U apply (T t) { /* can use x in field, and t parameter */ }
}

class C {
  I f () {
    int x = 0;
    I a = new D (x); // new instance of named class implementing I
    return a;
  }
}
</code></pre>
<ul>
<li>java concurrency</li>
</ul>
<pre><code class="lang-java"><span class="hljs-keyword">package</span> java.lang;

<span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> </span>{
  Thread (Runnable target); <span class="hljs-comment">// Allocates a new Thread object</span>
  ...
}
...
<span class="hljs-keyword">new</span> Thread (<span class="hljs-keyword">new</span> Runnable () {
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* packaged code here */</span> }
}).start ();
</code></pre>
<ul>
<li>scala using java concurrency</li>
</ul>
<pre><code class="lang-text">val threads : List[Thread] = {
  for (i &lt;- (1 to 26).toList) yield {
    val ch : Byte = (&apos;A&apos; + i - 1).asInstanceOf[Byte]
    new Thread (new Runnable {
      def run () = {
        while (true) { System.out.write (ch) }
      }
    })
  }
}
for (t &lt;- threads) { t.start }
</code></pre>
<h4 id="l-value">L-value</h4>
<ul>
<li>R-MODE AND L -MODE<ul>
<li>R-MODE: Right-hand <code>x</code> denotes value read from storage location</li>
<li>L-MODE:Left-hand <code>x</code> denotes the storage location </li>
<li>temporary value is not l value</li>
</ul>
</li>
<li><p>call by value</p>
<ul>
<li><p>For <code>g(x)</code> with <code>x = 5</code></p>
<p><code>x</code> evaluates to <code>5</code></p>
<p>a location containing <code>5</code> is given to <code>g</code></p>
<p>location is different to that of <code>x</code>!</p>
</li>
</ul>
</li>
<li>call by reference<ul>
<li>Some PLs use call-by-reference (CBR)</li>
<li>To run <code>g (e)</code><ul>
<li>evaluate <code>e</code> to an l-value <code>r</code></li>
<li>pass the l-value <code>r</code> to <code>g</code></li>
<li>callee changes via <code>r</code> are visible to caller</li>
</ul>
</li>
</ul>
</li>
<li>Can temporary values be passed as l-values?<ul>
<li><code>f(x+1)</code> is not obviously legitimate in CBR</li>
</ul>
</li>
<li><strong>SCALA: PASSING A FUNCTION</strong><ul>
<li>Scala allows functions as parameters</li>
<li>A function that takes no arguments can be seen as a delayed value, also called a thunk</li>
<li>Scala has a special syntax for using thunks as parameters, Call-by-name parameters are non-strict</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="argument-passing">argument passing</h4>
<h3 id="worksheet">worksheet</h3>
<h3 id="homework">homework</h3>
<h3 id="quiz">quiz</h3>
<h2 id="lecture8">Lecture8</h2>
<h3 id="class-notes">class notes</h3>
<h4 id="more-scope">More scope</h4>
<ul>
<li>in c</li>
</ul>
<pre><code class="lang-text">//The second  int x=x+1 is first int x, then execute x+1,so x is not initialize in the program
int main (void) {
  int x = 10;
  {
    int x = x + 1;
    printf (&quot;x = %08x\n&quot;, x);
  }
  return 0;
}
</code></pre>
<ul>
<li>in scala,  <code>val x:Int= x*1</code><ul>
<li>x is initialized  to 0 first when declaration, and then executing x*1, result is 0.</li>
</ul>
</li>
<li>Scala stream: more complex definition, recursive definition</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-comment">//worong recursive definition: when declared xs,xs is initialized as null, </span>
<span class="hljs-comment">//and we use xs in right part, this time xs is still null,and not Nil,so nullpointerException</span>
scala&gt; <span class="hljs-keyword">val</span> xs:<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-number">1</span> :: xs
java.lang.<span class="hljs-type">NullPointerException</span>
  ... <span class="hljs-number">28</span> elided
</code></pre>
<p>we can try by using class case version list, it is still wrong.</p>
<ul>
<li>Solving: try to delay evaluation of list tail, stream do it !</li>
<li>Stream: consider second parameter by name.</li>
<li><code>#::</code> is non-strict in right-hand argument</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-comment">//principle: using function to delay the evaluation of tail</span>
scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>(<span class="hljs-params">head:<span class="hljs-type">Int</span>, tail:(</span>)<span class="hljs-title">=&gt;T</span>)</span>
defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span></span>

scala&gt; <span class="hljs-keyword">val</span> ts:<span class="hljs-type">T</span> = <span class="hljs-type">T</span>(<span class="hljs-number">1</span>, ()=&gt;ts)
ts: <span class="hljs-type">T</span> = <span class="hljs-type">T</span>(<span class="hljs-number">1</span>,$$<span class="hljs-type">Lambda</span>$<span class="hljs-number">1324</span>/<span class="hljs-number">2038353966</span>@<span class="hljs-number">4</span>d500865)

scala&gt; ts.tail().tail().head
res14: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>
<span class="hljs-comment">// stream way:</span>
scala&gt; <span class="hljs-keyword">val</span> ones:<span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = <span class="hljs-number">1</span> #:: ones
ones: <span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>, ?)

scala&gt; ones.take (<span class="hljs-number">5</span>)
res0: scala.collection.immutable.<span class="hljs-type">Stream</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Stream</span>(<span class="hljs-number">1</span>, ?)

scala&gt; ones.take (<span class="hljs-number">5</span>).toList
res1: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
</code></pre>
<ul>
<li><strong>dynamic and static scope</strong></li>
<li>problem: <ul>
<li>inner function may have to use the variable which come from outer variable. if there are variables   using same name with outer variable,which one should the function use?</li>
<li>globle varible and local varible have same name in a function, ,when function use this name as variable, use which variable?<ul>
<li>1 possibility: using local variable in function and print global variable,beacause function is using the most recently declared variable ---- dynamic </li>
<li>2 possibility: using globle variable in function and print global variable,because x is bound to global x ----static</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">//dynamic scope language print 0</span>
<span class="hljs-comment">//static scope language print 1</span>
var x:Int = <span class="hljs-number">0</span>
<span class="hljs-function">def <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>{
  x = x + <span class="hljs-number">1</span>
}
<span class="hljs-function">def <span class="hljs-title">bar</span> <span class="hljs-params">()</span> </span>{
  var x:Int = <span class="hljs-number">0</span>
  foo ()
}
bar ()
println (x)
</code></pre>
<ul>
<li>static scope: identifiers are bound to the <strong>closest binding occurrence in an enclosing block of the program code.</strong> </li>
<li>dynamic scope:identifiers are bound to <strong>the binding occurrence in the closest activation record.</strong></li>
<li>dynamic scope language:lisp but common lisp fixed it </li>
<li>static scope language: scheme ,scala, java, python</li>
</ul>
<h4 id="case--studyjavascript-scope-and-function">case  study:Javascript (scope and function)</h4>
<ul>
<li>background summary<ul>
<li>dynamically-typed: compile time no error, just happen in runtime</li>
<li>object-oriented</li>
<li>functional</li>
<li>Runs in browsers and elsewhere with <a href="https://nodejs.org/en/" target="_blank">Node.js</a></li>
<li>use more functional  more than object</li>
<li>evolved fast</li>
</ul>
</li>
<li>javascript development option: jsbin</li>
<li>document object model<ul>
<li>DOM tree model of HTML document</li>
<li>Browser displays runtime changes to DOM tree</li>
<li>JS introduced for manipulating DOM tree</li>
<li>Callback functions for event handling</li>
</ul>
</li>
<li>JS WAT(horrible part)</li>
<li>syntax<ul>
<li>print:console.log (1 + 2);</li>
<li>document: be displayed in the browser</li>
<li>function:</li>
</ul>
</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> (<span class="hljs-params">x</span>) </span>{
  <span class="hljs-built_in">console</span>.log (<span class="hljs-string">&quot;Called with &quot;</span> + x);
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
}

f (<span class="hljs-number">5</span>);
</code></pre>
<ul>
<li><strong>javascript scope and closures</strong></li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-comment">//the declara of a in function f is hoisted in top of function f </span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log (<span class="hljs-string">&quot;f1: a = &quot;</span> + a);
  { <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-built_in">console</span>.log (<span class="hljs-string">&quot;f2: a = &quot;</span> + a);
} }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log (<span class="hljs-string">&quot;m1: a = &quot;</span> + a);
  f ();
  <span class="hljs-built_in">console</span>.log (<span class="hljs-string">&quot;m2: a = &quot;</span> + a);

output: 
<span class="hljs-number">1</span>
<span class="hljs-literal">undefined</span>
<span class="hljs-number">2</span> 
<span class="hljs-number">1</span>
</code></pre>
<ul>
<li>javascript scope<ul>
<li>hoisting: the enclosing declared a variable, the declaration will be hoisted to top of function, and initialize to &quot;undefined&quot;, even if I have a condition and condition is false.</li>
<li>let: is  fixed this let x, is in the block it should be </li>
</ul>
</li>
<li>collection processing<ul>
<li>var xs = [ 11, 21, 31 ]; </li>
<li>xs.map (x =&gt; (2 * x)); [22,42,62]</li>
<li>xs.filter (x =&gt; x%7===0) :[21]</li>
<li>xs.reduce (((z,x) =&gt; z+x), 0): 0+11+21+31</li>
</ul>
</li>
<li>common scope problem<ul>
<li>if I want both inner and outer function can change a variable, then create a closure</li>
<li>if I want the variable only can change in outer function and stop change in inner function, we can use  blcok scope: let <ul>
<li>of no let, we can use IIFE, which create a scope that local variable can only survive in inner function</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> funcs = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
<span class="hljs-comment">//the function here is for give me a scope, so that x can only survive in the scope?</span>
  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ 
    <span class="hljs-keyword">var</span> x = i;
    funcs.push (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> x; });
  }) ();
}
<span class="hljs-built_in">console</span>.log (funcs[<span class="hljs-number">0</span>] ()); <span class="hljs-comment">// prints 0</span>
</code></pre>
<ul>
<li><strong>javascript object oriented</strong><ul>
<li>java OOP </li>
</ul>
</li>
</ul>
<pre><code class="lang-java"><span class="hljs-comment">//define a object in java</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">employee</span></span>{
    String name;
    Int id;   
}
<span class="hljs-keyword">new</span> emplyee()
</code></pre>
<ul>
<li>javascript is different:<ul>
<li>JS is not class-based: no class definition</li>
<li>Object literals have properties (<code>name</code>, <code>age</code>, <code>addr</code>)</li>
<li>JSON: javascript object noation</li>
<li>javascript OOP and add field dynamically and modify exsiting field properly</li>
</ul>
</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-comment">// Object literal with no contents</span>
<span class="hljs-keyword">var</span> empty = {};

<span class="hljs-comment">// Object literal with three properties</span>
<span class="hljs-keyword">var</span> person = {
  name: <span class="hljs-string">&quot;Alice&quot;</span>,
  age: <span class="hljs-number">50</span>,
  addr: <span class="hljs-string">&quot;243 S Wabash Ave&quot;</span>
};
</code></pre>
<ul>
<li><ul>
<li>keys are always Strings</li>
<li>{}: empty object and empty expression</li>
<li>it you call the method or field is not there<ul>
<li>in java: compiler error </li>
<li>javascript<ul>
<li>object even ({})(empty object): undefined</li>
<li>variable:not a object: cannot read property of &quot;variable&quot; of undefined</li>
<li>undefined variable: &quot;variable&quot; is not defined</li>
</ul>
</li>
</ul>
</li>
<li>enmerate properties: specical iterate syntax</li>
</ul>
</li>
</ul>
<pre><code class="lang-text">var person = {
  name: &quot;Alice&quot;,
  age: 50,
  addr: &quot;243 S Wabash Ave&quot;
};

for (p in person) {
  console.log (p + &quot;: &quot; + person[p]);
}
</code></pre>
<ul>
<li>Function: no different between function and method</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-comment">//object counter with field n and fucntion get</span>
<span class="hljs-keyword">var</span> counter = { n: <span class="hljs-number">0</span>, get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.n++; } };
<span class="hljs-comment">// n is in inner function,so have specify this</span>
<span class="hljs-keyword">var</span> counter = { n: <span class="hljs-number">0</span>, get () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.n++; } };
</code></pre>
<ul>
<li>encapsulation for object<ul>
<li>Encapsulation via private fields/methods for PLs</li>
<li>JS properties cannot be declared private<ul>
<li>no classes</li>
<li>which code could access &quot;private&quot; properties?<ul>
<li>inner function local variable </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-comment">//return an object with a function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCounter</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> {
    get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> n++; } <span class="hljs-comment">// n++ NOT this.n++</span>
  };
};

<span class="hljs-keyword">var</span> counter = createCounter ();
counter.get ();
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//scala version just return a function, extreact function from object</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createCounter</span> </span>() : () =&gt; <span class="hljs-type">Int</span> = {
  <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>
  () =&gt; { <span class="hljs-keyword">val</span> retVal = n; n = n + <span class="hljs-number">1</span>; retVal }
}

<span class="hljs-keyword">val</span> counter = createCounter () 
counter ()
</code></pre>
<ul>
<li>jquery is a library for javascript</li>
<li>continue javascript OOD</li>
<li>delegation/prototype based inheritance<ul>
<li>problem<ul>
<li>employee application, how do they diff?diff name, salary. how do they same? same function, increaseSalary(), change()</li>
<li>original class<ul>
<li>Attribute:separate</li>
<li>function: share<ul>
<li>function create a local variable,varible and function share the memory, but when new a object, it will start over</li>
</ul>
</li>
<li>new objects have separate place to store field and a link to function, and a shared place to store function code</li>
</ul>
</li>
<li>but javascript, they don&quot;t have class</li>
<li>solving: delegation<ul>
<li>embedding class as object, and store method in here, a pointer called prototype</li>
</ul>
</li>
</ul>
</li>
<li>this<ul>
<li>JS binds <code>this</code> based on calling context. <ul>
<li><code>o.m()</code> is method context, <code>this===o</code></li>
<li><code>f()</code> is function context, <code>this===global/window</code></li>
<li><code>new C()</code> is constructor context, <code>this</code> is new object</li>
</ul>
</li>
</ul>
</li>
<li>function is  method in javascript<ul>
<li>problem 2<ul>
<li>function in object is a closure,  closures aren&apos;t bind &quot;this&quot;, this is bound to the globle object, but scala different</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-text">//javascript return a function, which create a closure, the closure is not bind this,
//so the closure is not bind o
var o = {
  v : 5,
  add : function (xs) {
    return xs.map(function(x){ return this.v + x; });
  }
}
o.add([10,20,30]) // [ NaN, NaN, NaN ]
</code></pre>
<ul>
<li><ul>
<li>solution:</li>
</ul>
</li>
</ul>
<pre><code class="lang-text">var o = {
  v : 5,
  add : function (xs) {
    return xs.map(function(x){ return this.v + x; }.bind(this));
  }
}
o.add([10,20,30]) // [ 15, 25, 35 ]
</code></pre>
<ul>
<li>js view properties</li>
<li>js object is separate, function are shared<ul>
<li>js object cointains propertie of the object and the properties of prototype,so that fucntion can be share</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="homework">homework</h3>
<h3 id="quiz">quiz</h3>
<h2 id="lecture9">Lecture9</h2>
<h3 id="class-notes">class notes</h3>
<h4 id="dynamic-dispatch">dynamic dispatch</h4>
<ul>
<li>encapsulation<ul>
<li>private: object in this class can see</li>
</ul>
</li>
<li>direct calls:refer to callee directly by name<ul>
<li>indirect call:C allows indirection to code via function pointers</li>
<li>diff: in assembly: direct just name where we will going; indirect we put  the place in the register, and then we jump to the value stored in register</li>
</ul>
</li>
<li>example of indirect call</li>
</ul>
<pre><code class="lang-text">//indirect calls:A type of array should bind with A function,
// but it return its actual time of function, so it is dynamic dispatch
class A           { void foo () { System.out.println (&quot;A&quot;); } }
class B extends A { void foo () { System.out.println (&quot;B&quot;); } }
class C extends A { void foo () { System.out.println (&quot;C&quot;); 

public class Driver {
  public static void main (String[] args) { 
    A[] as = { new B(); new C (); }
    for (A x : as)
      x.foo ();
  }
}
</code></pre>
<ul>
<li>&#x1F602;:dynamic dispatch: object and function() binding together; if it occur in runtime, it is dynamic dispatch; if it occur in compile time, it is static binding</li>
<li>Java / Scala anon. functions use dynamic dispatch,Implementation of dynamic dispatch in C++ soon</li>
</ul>
<h4 id="subtyping">subtyping</h4>
<ul>
<li><p>interface=contact</p>
<ul>
<li><p>Informal usage for dynamically-typed PLs</p>
<ul>
<li>documentation describes what is allowed</li>
<li>dynamic errors may occur if the interface is not obeyed or the interface was incorrect<ul>
<li>dynamic typed PL, they only talk about what field they has, properties they have </li>
<li>if you don&apos;t have this properties, the dynamic error occur</li>
</ul>
</li>
</ul>
<p>Formal usage for statically-typed PLs</p>
<ul>
<li>static checks that data uses interfaces correctly</li>
<li>to eliminate dynamic errors</li>
<li>These slides apply to statically-typed PL</li>
</ul>
</li>
</ul>
</li>
<li><p>focus on static typed language</p>
<ul>
<li>subtyping :c have all the properties of B (canry and bird)<ul>
<li>C&lt;:B</li>
<li>scala: from nothing to any</li>
</ul>
</li>
<li><p>subtyping and substitution</p>
<ul>
<li>upcasting<ul>
<li>If <code>Y&lt;:X</code> and <code>e:Y</code>, then <code>e:X</code> also<ul>
<li>(because <code>e</code> satisfies the contract for type <code>X</code>)</li>
<li>if someone wants a bird, he is happy to get a canry</li>
<li>This substitution is sometimes called upcasting</li>
</ul>
</li>
</ul>
</li>
<li>downcasting<ul>
<li>Downcasting is potentially unsafe<ul>
<li>requires explicit cast in Java, Scala, etc.</li>
<li>also requires storing type at runtime</li>
<li>downcast introduces a dynamic check (Java)</li>
</ul>
</li>
<li>subtyping preorder<ul>
<li>Subtyping relation <code>&lt;:</code> is a preorder on types<ul>
<li>reflexive - <code>X&lt;:X</code></li>
<li>transitive - if <code>X&lt;:Y</code> and <code>Y&lt;:Z</code> then <code>X&lt;:Z</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>PL</code></p>
<ul>
<li><p><code>top</code></p>
<ul>
<li><p>Some PLs have a <code>Top</code> type</p>
<ul>
<li><code>X&lt;:Top</code> (greater than all other types)</li>
</ul>
<p>In Java - <code>java.lang.Object</code> above reference types</p>
<p>In Scala - <code>scala.Any</code> above all types</p>
</li>
<li><p>In Scala - <code>scala.AnyRef</code> above reference types</p>
</li>
</ul>
</li>
<li><p>bottom</p>
<ul>
<li><p>Most PLs do not have a <code>Bottom</code> type</p>
<ul>
<li><code>Bottom&lt;:X</code> (less than all other types)</li>
</ul>
<p>Recall <a href="http://fpl.cs.depaul.edu/jriely/courses/csc447/assets/images/ScalaClassHierarchy_New.png" target="_blank">Scala type hierarchy</a></p>
<p>In Scala - <code>Bottom</code> is <code>scala.Nothing</code></p>
<p>Important for typing uses of <code>Nil</code></p>
<ul>
<li><code>Nil:List[Nothing]</code></li>
<li><code>List[Nothing]&lt;:List[X]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>List<ul>
<li>Subtyping for Scala lists: If <code>Y&lt;:X</code> then <code>List[Y]&lt;:List[X]</code></li>
</ul>
</li>
<li><p><strong>COVARIANCE:referent to same thing, but have different type parameter</strong></p>
<ul>
<li><p><code>List</code> said to be covariant&#xFF0C; arrays is not covariant</p>
<p>Generally, <code>C[-]</code> is covariant if and only if</p>
<ul>
<li><code>Y&lt;:X</code> implies <code>C[Y]&lt;:C[X]</code></li>
</ul>
</li>
</ul>
</li>
<li>invariant<ul>
<li>scala array invariant</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> </span>(x:<span class="hljs-type">Int</span>) : <span class="hljs-type">Int</span>             = <span class="hljs-number">1</span> 
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>{
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> </span>(x:<span class="hljs-type">Int</span>) : <span class="hljs-type">Int</span>    = <span class="hljs-number">2</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span> </span>() : <span class="hljs-type">Int</span>                  = <span class="hljs-number">3</span>
}

<span class="hljs-keyword">val</span> xs1:<span class="hljs-type">Array</span>[<span class="hljs-type">B</span>] = <span class="hljs-type">Array</span> (<span class="hljs-keyword">new</span> <span class="hljs-type">B</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>) <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">val</span> xs2:<span class="hljs-type">Array</span>[<span class="hljs-type">C</span>] = <span class="hljs-type">Array</span> (<span class="hljs-keyword">new</span> <span class="hljs-type">C</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">C</span>) <span class="hljs-comment">// OK</span>
<span class="hljs-keyword">val</span> xs3:<span class="hljs-type">Array</span>[<span class="hljs-type">B</span>] = <span class="hljs-type">Array</span> (<span class="hljs-keyword">new</span> <span class="hljs-type">B</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">C</span>) <span class="hljs-comment">// OK, because C &lt;: B</span>
<span class="hljs-keyword">val</span> xs4:<span class="hljs-type">Array</span>[<span class="hljs-type">B</span>] = xs2 <span class="hljs-comment">// Not allowed; following steps must not occur</span>
xs4 (<span class="hljs-number">0</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>        <span class="hljs-comment">// OK, because xs4:Array[B]</span>
xs2 (<span class="hljs-number">0</span>).g ()           <span class="hljs-comment">// OK because xs2 (0) : C (statically)</span>
                       <span class="hljs-comment">// but fails because xs2 (0) : B (dynamically)</span>
</code></pre>
<p>cannot have two different reference to same array</p>
<ul>
<li>scala not allow upcasting and downcasting</li>
<li>java  array convariant</li>
</ul>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
    C[] xs2 = <span class="hljs-keyword">new</span> C[] { <span class="hljs-keyword">new</span> C (), <span class="hljs-keyword">new</span> C () };
    B[] xs4 = xs2;     <span class="hljs-comment">// Uses covariance of Java arrays</span>
    xs4[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> B (); <span class="hljs-comment">// Compiles OK, fails at runtime</span>
    xs2[<span class="hljs-number">0</span>].g (<span class="hljs-keyword">new</span> String[] { }); 
  }
}
</code></pre>
<ul>
<li>java allow upcastign and downcasting, not allow change</li>
</ul>
<h3 id="worksheet">worksheet</h3>
<h3 id="homework">homework</h3>
<h3 id="quiz">quiz</h3>
<h2 id="lecture10">Lecture10</h2>
<h3 id="class-notes">class notes</h3>
<h4 id="inheritance">inheritance</h4>
<ul>
<li>subtyping:  one type can be used as different type,  bird is a canary</li>
<li>inheritance: reuse  the code</li>
<li>delegation id different from inheritance </li>
</ul>
<h4 id="case-study-c-and-vtable">case study: c++ and vtable</h4>
<ul>
<li>OO feather<ul>
<li>object heap allocation:Counter C</li>
<li>object stack allocation:Cunter *p=new Counter();</li>
</ul>
</li>
<li>inheritance<ul>
<li>fields</li>
</ul>
</li>
<li>dispatch<ul>
<li>default: static dispatch</li>
<li>dynamic dispatch: virtual</li>
</ul>
</li>
</ul>
<h3 id="worksheet">worksheet</h3>
<h3 id="homework">homework</h3>
<h3 id="quiz">quiz</h3>
<h2 id="scala-method">Scala method</h2>
<ul>
<li>List method</li>
</ul>
<pre><code class="lang-scala"><span class="hljs-comment">// isEmpty:input a list return boolean, spliting to two situation</span>
<span class="hljs-comment">// if list has element return true, else return false</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEmpty</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>]) : <span class="hljs-type">Boolean</span> = xs <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; <span class="hljs-literal">true</span>
  <span class="hljs-keyword">case</span> y::ys =&gt; <span class="hljs-literal">false</span>
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//head: input a list return a element of list(head)</span>
<span class="hljs-comment">//return first element of list, else throw exception</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">head</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>]) : <span class="hljs-type">X</span> = xs <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NoSuchElementException</span> ()
  <span class="hljs-keyword">case</span> y::ys =&gt; y
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//tail:input a list return a list(without head)</span>
<span class="hljs-comment">//return all element without head, else throw a exception</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tail</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>]) : <span class="hljs-type">List</span>[<span class="hljs-type">X</span>] = xs <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NoSuchElementException</span> ()
  <span class="hljs-keyword">case</span> y::ys =&gt; ys
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//append:intput two list with same type element,return one list</span>
<span class="hljs-comment">//if list a has element, append that element with new list recursively,</span>
<span class="hljs-comment">//if list a has no element, append list b to new list</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>], ys:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>]) : <span class="hljs-type">List</span>[<span class="hljs-type">X</span>] = xs <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; ys
  <span class="hljs-keyword">case</span> z::zs =&gt; z::(append (zs, ys))
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//foreach:input a list with any type and a function take list element and return unit</span>
<span class="hljs-comment">//take first element into f function and recursively do this</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foreach</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>], f:<span class="hljs-type">X</span>=&gt;<span class="hljs-type">Unit</span>) : <span class="hljs-type">Unit</span> = {
  xs <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; ()
    <span class="hljs-keyword">case</span> y::ys =&gt; { 
      f (y)
      foreach (ys, f)
    }
  }
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">// sum: input a list of Int and return a sum of them</span>
<span class="hljs-comment">//using a variable inside sum, and for each function, sum every element in the list with result and print result</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span> </span>(xs:<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]) : <span class="hljs-type">Int</span> = {
  <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>
  xs.foreach ((x:<span class="hljs-type">Int</span>) =&gt; result = result + x)
  result
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">// transform: input a list of someting and resturn a list of otherthing.</span>
<span class="hljs-comment">//take the first element and transform it and then recursively do that</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span> </span>(xs:<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]) : <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = {
  xs <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; <span class="hljs-type">Nil</span>
    <span class="hljs-keyword">case</span> y::ys =&gt; (<span class="hljs-string">&quot;%02d&quot;</span>.format (y)) :: transform (ys)
  }
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//map: input a list of X and return a list of Y</span>
<span class="hljs-comment">//take the first element into f function and recursively do that,</span>
<span class="hljs-comment">//which is map the element to f function</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span> </span>[<span class="hljs-type">X</span>,<span class="hljs-type">Y</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>], f:<span class="hljs-type">X</span>=&gt;<span class="hljs-type">Y</span>) : <span class="hljs-type">List</span>[<span class="hljs-type">Y</span>] = {
  xs <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; <span class="hljs-type">Nil</span>
    <span class="hljs-keyword">case</span> y::ys =&gt; f (y) :: map (ys, f)
  }
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//identity: input a list of X return same list of X</span>
<span class="hljs-comment">//combine y with recursive function</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identity</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>]) : <span class="hljs-type">List</span>[<span class="hljs-type">X</span>] = {
  xs <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; <span class="hljs-type">Nil</span>
    <span class="hljs-keyword">case</span> y::ys =&gt; y :: identity (ys)
  }
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//filter: input a list X return a filted list</span>
<span class="hljs-comment">//take y to conditional argument if true return, else delete y and recursively argue next y</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>], f:<span class="hljs-type">X</span>=&gt;<span class="hljs-type">Boolean</span>) : <span class="hljs-type">List</span>[<span class="hljs-type">X</span>] = {
  xs <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>            =&gt; <span class="hljs-type">Nil</span>
    <span class="hljs-keyword">case</span> y::ys <span class="hljs-keyword">if</span> f (y) =&gt; y :: filter (ys, f)
    <span class="hljs-keyword">case</span> _::ys          =&gt; filter (ys, f)
  }
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//foldleft:input a list, a accumulator and a function return a number</span>
<span class="hljs-comment">//execute f first and then recursion: z,f,foldleft,f,foldleft</span>
<span class="hljs-comment">//the recursion occur in the last step of function, parameter change as a recusion</span>
<span class="hljs-comment">//it don&apos;t use too much stack memory</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldLeft</span> </span>[<span class="hljs-type">Z</span>,<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>], z:<span class="hljs-type">Z</span>, f:((<span class="hljs-type">Z</span>,<span class="hljs-type">X</span>)=&gt;<span class="hljs-type">Z</span>)) : <span class="hljs-type">Z</span> =  xs <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; z
  <span class="hljs-keyword">case</span> y::ys =&gt; foldLeft (ys, f(z,y), f)
}
<span class="hljs-keyword">val</span> xss = <span class="hljs-type">List</span>(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-type">List</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>),<span class="hljs-type">List</span>(<span class="hljs-number">8</span>,<span class="hljs-number">9</span>),<span class="hljs-type">List</span>(<span class="hljs-number">10</span>))
foldLeft (xss, <span class="hljs-number">0</span>, (z:<span class="hljs-type">Int</span>,xs:<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>])=&gt;z + xs.length)
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//foldright:input a list,a accumulator and a fucntion return a number</span>
<span class="hljs-comment">//execute recursion first then f function: foldright,foldright,foldright...,z,f,f,f,f...</span>
<span class="hljs-comment">//the recusion occur before the f executing, it will use stack everytime recursion execute</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldRight</span> </span>[<span class="hljs-type">X</span>,<span class="hljs-type">Z</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>], z:<span class="hljs-type">Z</span>, f:((<span class="hljs-type">X</span>,<span class="hljs-type">Z</span>)=&gt;<span class="hljs-type">Z</span>)) : <span class="hljs-type">Z</span> =  xs <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; z
  <span class="hljs-keyword">case</span> y::ys =&gt; f (y, foldRight (ys, z, f))
}
<span class="hljs-keyword">val</span> xss = <span class="hljs-type">List</span>(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-type">List</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>),<span class="hljs-type">List</span>(<span class="hljs-number">8</span>,<span class="hljs-number">9</span>),<span class="hljs-type">List</span>(<span class="hljs-number">10</span>))
foldRight (xss, <span class="hljs-number">0</span>, (xs:<span class="hljs-type">List</span>[<span class="hljs-type">Int</span>],z:<span class="hljs-type">Int</span>)=&gt;xs.length + z)
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//flatten: input a list of list and return a list of element</span>
<span class="hljs-comment">//using concatenate notation to connect element and list</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatten</span> </span>[<span class="hljs-type">X</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-type">X</span>]]) : <span class="hljs-type">List</span>[<span class="hljs-type">X</span>] = xs <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; <span class="hljs-type">Nil</span>
  <span class="hljs-keyword">case</span> y::ys =&gt; y ::: flatten(ys)
}
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">//flatMap: input a List of X and a function, which change X to a list and return list</span>
<span class="hljs-comment">//pass a list of element to f function and return a list and combine with other list</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span> </span>[<span class="hljs-type">X</span>,<span class="hljs-type">Y</span>] (xs:<span class="hljs-type">List</span>[<span class="hljs-type">X</span>], f:<span class="hljs-type">X</span>=&gt;<span class="hljs-type">List</span>[<span class="hljs-type">Y</span>]) : <span class="hljs-type">List</span>[<span class="hljs-type">Y</span>] = {
  xs <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span>   =&gt; <span class="hljs-type">Nil</span>
    <span class="hljs-keyword">case</span> y::ys =&gt; f (y) ::: flatMap (ys, f)
  }
}
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="_book/untitled.md" class="navigation navigation-prev " aria-label="Previous page: Untitled">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="data-structure-review-in-java.html" class="navigation navigation-next " aria-label="Next page: Data Structure Review In Java">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"the language included are scheme, c, java, scala, javascript","title":"Csc 447 Review","level":"1.3","depth":1,"next":{"title":"Data Structure Review In Java","level":"1.4","depth":1,"path":"data-structure-review-in-java.md","ref":"data-structure-review-in-java.md","articles":[]},"previous":{"title":"Untitled","level":"1.2.2","depth":2,"path":"_book/untitled.md","ref":"_book/untitled.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"csc-447-review.md","mtime":"2021-03-03T04:28:22.025Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2021-03-03T04:33:29.453Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

